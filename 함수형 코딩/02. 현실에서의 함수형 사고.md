# 🔖 02. 현실에서의 함수형 사고

## ✏️ 1. 파트 1: 액션과 계산, 데이터

1. 액션: 호출 횟수와 시점에 의존하는 것 (e.g. 반죽 펴기, 피자 배달, 재료 주문)
2. 계산: 어떤 것을 결정하거나 계획하는 것으로 실행해도 다른 곳에 영향을 주지 않음 (e.g. 조리법에 나온 것을 두 배로 만들기, 쇼핑 목록 결정)
3. 데이터: 유연하기 때문에 저장하거나 네트워크로 전송하는 등 다양하게 쓸 수 있음 (e.g. 고객 주문, 영수증, 조리법)

## ✏️ 2. 변경 가능성에 따라 코드 나누기

> 함수형 프로그래머는 아래에서 설명하는 아키텍처 패턴이 게층을 만들기 때문에 **계층형 설계<sub>stratified design</sub>라고** 부른다. 계층형 설계는 일반적으로 _비즈니스 규칙, 도메인 규칙, 기술 스택 계층으로_ 나뉜다.

각 계층은 그 아래에 있는 계층을 기반으로 만들어지기 때문에 각 계층에 있는 코드는 더 안정적인 기반 위에 작성할 수 있다. 이런 구조로 소프트웨어를 만들면 코드를 쉽게 변경할 수 있게 된다. 가장 위에 있는 코드는 의존성이 거의 없기 때문에 쉽게 바꿀 수 있으며, 아래에 있는 코드들은 위에 있는 코드보다 의존성이 많아 바꾸기 어려워 자주 바뀌지 않는다.

![stratified design](https://blog.kakaocdn.net/dn/wPHuE/btssAIqKWTH/YWxEpdVqoThQfbewG1EIVK/img.png)

## ✏️ 3. 분산 시스템을 타임라인으로 시각화하기

> 타임라인 다이어그램을 사용하면 액션이 시간 순서에 따라 어떻게 실행되는지 볼 수 있다. 타임라인을 서로 맞추지 않은 분산 시스템은 예측 불가능한 순서로 진행된다.

![timeline](https://velog.velcdn.com/images/minsu8834/post/e19325c7-f731-4016-9c91-9ff9a98c963f/image.png)

### 1. 어려운 경험을 통해 분산 시스템에 대해 배운 것

1. 기본적으로 타임라인은 서로 순서를 맞추지 않는다. 때문에 서로 실행 순서를 맞추는 과정이 필요하다.
2. 액션이 실행되는 시간은 중요하지 않다. 각각의 타임라인은 다른 타임라인의 순서와 관계없이 만들어야 한다.
3. 드물지만 타이밍이 어긋나는 경우는 실제로 일어난다. 타임라인은 항상 올바른 결과를 보장해야 한다.
4. 타임라인 다이어그램으로 시스템의 문제를 알 수 있다.

![abstaction](https://velog.velcdn.com/images/hazae23/post/00b5025d-8ef3-488f-bcc3-c5982c984228/image.png)

### 2. 타임라인 커팅: 로봇이 서로를 기다릴 수 있게 하기

> 타임라인 커팅은 여러 타임라인이 동시에 진행될 때 서로 순서를 맞추는 방법이다. 컷이 있으면 점선 아래에 있는 것은 위에 있는 것이 끝나야 실행할 수 있다. 컷이 있기 때문에 재료 준비 작업들의 실행 순서를 신경 쓰지 않고 피자 만드는 나머지 작업을 진행할 수 있다.

### 3. 좋은 경험을 통해 타임라인에 대해 배운 것

1. 타임라인 커팅으로 서로 다른 작업들을 쉽게 이해할 수 있다.
2. 타임라인 다이어그램을 사용하면 시간에 따라 진행하는 작업을 쉽게 이해할 수 있다. (동시에 실행되는 분산형 시스템 시각화에 좋음)
3. 타임라인 다이어그램은 유연하다.

![timeline cutting](https://blog.kakaocdn.net/dn/vdNFW/btsF4VqE1Nm/jLKpGwHGJkAkoWHRmmZbN0/img.png)

## ✏️ 3. 요점 정리

- 함수형 프로그래머는 유지보수를 잘하기 위해 계층형 설계를 사용한다. 각 계층은 코드의 변경 가능성에 따라 나눈다.
- 타임라인 다이어그램은 시간에 따라 변하는 액션을 시각화한 방법이다. 이를 통해 액션이 다른 액션과 어떻게 연결되는지 볼 수 있다.
- 타임라인 커팅은 액션이 올바른 순서로 실행할 수 있도록 보장해 준다.

# REFERENCE

쏙쏙 들어오는 함수형 코딩 2장 현실에서의 함수형 사고
